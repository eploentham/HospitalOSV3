package com.hospital_os.objdb;import com.hospital_os.usecase.connection.*;import com.hospital_os.utility.*;import com.hospital_os.usecase.connection.*;import com.hospital_os.object.*;import java.util.*;import java.sql.*;import java.text.*;public class SequenceDataDB{    public ConnectionInf theConnectionInf;    public SequenceData dbObj;    final public String idtable = "239";    private String year2d;        /**     * @param ConnectionInf db     * @roseuid 3F65897F0326     */        public SequenceDataDB(ConnectionInf db)    {        theConnectionInf=db;        dbObj = new SequenceData();        initConfig();    }    public boolean initConfig()    {        dbObj.table="b_sequence_data";        dbObj.pk_field="b_sequence_data_id";        dbObj.name   ="sequence_data_description";        dbObj.pattern   ="sequence_data_pattern";        dbObj.value="sequence_data_value";        dbObj.active="sequence_data_active";        return true;    }    /**     * @param cmd     * @param o     * @return int     * @roseuid 3F6574DE0394     */        public int insert(SequenceData o) throws Exception    {        String sql="";        SequenceData p=o;        p.generateOID(idtable);        sql="insert into " + dbObj.table + " ("        + dbObj.pk_field        + " ,"	+ dbObj.name        + " ,"	+ dbObj.pattern        + " ,"	+ dbObj.value        + " ,"	+ dbObj.active        + " ) values ('"        + p.getObjectId()        + "','" + p.name        + "','" + p.pattern        + "','" + p.value        + "','" + p.active        + "')";        sql = Gutil.convertSQLToMySQL(sql,theConnectionInf.gettypeDatabase());        return theConnectionInf.eUpdate(sql);    }        public int update(SequenceData o) throws Exception    {        return update(o,true);    }    private int update(SequenceData o,boolean is_updateseq) throws Exception    {        String sql="update " + dbObj.table + " set ";        SequenceData p=o;        String field =""        + "', " + dbObj.name + "='" + p.name        + "', " + dbObj.pattern + "='" + p.pattern        + "', " + dbObj.value + "='" + p.value        + "', " + dbObj.active + "='" + p.active        + "' where " + dbObj.pk_field + "='" + p.getObjectId() +"'";        sql = Gutil.convertSQLToMySQL(sql+field.substring(2),theConnectionInf.gettypeDatabase());        if(is_updateseq)            updateSequence(o);        return theConnectionInf.eUpdate(sql);    }    public int updateSequence(SequenceData p) throws Exception{            int val = Integer.parseInt(p.value)-1;            String seq_name = "";            if(p.getObjectId().equals("hn"))                seq_name = "t_patient_hn";            else if(p.getObjectId().equals("vn"))                seq_name = "t_visit_vn";            else if(p.getObjectId().equals("an"))                seq_name = "t_visit_an";            else                return 1;            if(val==0){                try{                    theConnectionInf.eUpdate("drop sequence "+ seq_name +";");                }catch(Exception e){                    Constant.println(e.getMessage());                }                   try{                    theConnectionInf.eUpdate("create sequence "+ seq_name +";");                }catch(Exception e){                    Constant.println(e.getMessage());                }               }            else                theConnectionInf.eQuery("select setval('" + seq_name + "'," + val + ");");                        return 0;    }    public int delete(SequenceData o) throws Exception    {        String sql="delete from " + dbObj.table        + " where " + dbObj.pk_field + "='" + o.getObjectId() +"'";        return theConnectionInf.eUpdate(sql);    }        public SequenceData selectByPK(String pk) throws Exception    {        String sql="select * from " + dbObj.table        + " where " + dbObj.pk_field        + " = '" + pk + "'";                Vector v=eQuery(sql);        if(v.size()==0)            return null;        else            return (SequenceData)v.get(0);    }        public Vector selectAll() throws Exception    {        String sql="select * from " + dbObj.table;                Vector v=eQuery(sql);        if(v.size()==0)            return null;        else            return v;    }        public Vector selectBySearch(String data) throws Exception    {        String sql="select * from " + dbObj.table ;        if(data.length() != 0)        {   sql = sql + " Where " +dbObj.pk_field +"= '" + data + "'";        }        sql += " order by "+ dbObj.name;                Vector v=eQuery(sql);        if(v.size()==0)            return null;        else            return v;    }            public Vector selectLikePattern(String data) throws Exception    {        String sql="select * from " + dbObj.table ;        if(data.length() != 0)           sql = sql + " Where upper(" + dbObj.pattern + ") like upper('" + data + "')";        Vector v=eQuery(sql);        if(v.size()==0)         return null;        else                    return v;    }            /**     *   hn_runing true จะ ไม่ใช้ปี พ.ศ. นำหน้า     *             false จะ ใช้ปี พ.ศ. นำหน้า     *  ลำดับอันนี้จะแสดงเลขที่ถัดไปที่จะได้ในอนาคต      *  แต่ว่าในเวอร์ชัน 3.7 บางโรงไปแสดงเลขที่สุดท้ายไม่ไช่เลขที่จะได้ในอนาคต     */    public String updateSequence(String str,boolean hn_runing) throws Exception    {        boolean update_seq = false;        int value = 1;        int sd_value = 1;        SequenceData sd = selectByPK(str);        try{            sd_value = Integer.parseInt(sd.value);        }        catch(Exception e){            e.printStackTrace(Constant.getPrintStream());        }        if(str.equals("hn")){            ResultSet rs = theConnectionInf.eQuery("select nextval('t_patient_hn')");            if(rs.next())  value = rs.getInt(1);                value = sd_value;                update_seq = true;        }        else if(str.equals("vn")){            ResultSet rs = theConnectionInf.eQuery("select nextval('t_visit_vn')");            if(rs.next())  value = rs.getInt(1);                value = sd_value;                update_seq = true;        }        else if(str.equals("an")){            ResultSet rs = theConnectionInf.eQuery("select nextval('t_visit_an')");            if(rs.next())  value = rs.getInt(1);                value = sd_value;                update_seq = true;        }           //henbe: ไม่ต้องเช็คเป็นขึ้นตอนของ control ที่จะต้องเช็คก่อนหน้านี้        //pu:ตรวจสอบ Max seq ของ hn_hcis //        else if(str.equals("hn_hcis"))//        {//            //pu: 1.หาค่า max ของ hn_hcis//            ResultSet rs = theConnectionInf.eQuery("select max( " +//                    " cast(case when(t_health_family.health_family_hn_hcis <> '') " +//                    " then trim(t_health_family.health_family_hn_hcis) " +//                    " else '000000' end   as numeric)) " +//                    " from t_health_family");//            if(rs.next())//                value = rs.getInt(1);//            //pu: 2.ถ้ารหัสที่ให้ซ้ำ จะเพิ่มค่าให้กับ hn_hcis_next แล้วนำไปตรวจสอบอีกว่า ซ้ำหรือไม่//            value = getMaxHnHCIS(value+1);//            update_seq = false;//        }        else        {            value = sd_value;        }        String ret_value=null;        //Constant.println("______________________________sd.active" + sd.active);        if(sd.active.equals("1"))            ret_value = getSeqPattern(sd.pattern,value);        else            ret_value = updateSequenceV36(str, hn_runing,value);                //101106 henbe ก็ได้แก้ให้แล้วเป็นเลขที่ถัดไปที่จะได้ในอนาคตให้เหมือนเดิม        sd.value = String.valueOf(value + 1);        update(sd,update_seq);        return ret_value;    }        /**     *ตรวจสอบเลข HN_HCIS ซ้ำกันในตาราง t_health_family หรือไม่     *ถ้าซ้ำจะทำการเพิ่มค่า value ไปอีก 1 แล้วทำการ check จนว่า จะไม่เจอข้อมูลซ้ำในฐานข้อมูล     *@param value ค่า hn_hcis สูงสุดที่ดึงจาก t_healt_family     *@return value ค่า hn_hcis สูงสุดที่ดึงจาก t_healt_family และไม่ซ้ำกันใน t_healt_family     *@author pu     *@date 23/09/2008     */    private int getMaxHnHCIS(int value) throws Exception    {        ResultSet rs_check = theConnectionInf.eQuery("select * from t_health_family where health_family_hn_hcis like '" + value + "'");        while(rs_check.next())        {            value++;            rs_check = theConnectionInf.eQuery("select * from t_health_family where health_family_hn_hcis like '" + value + "'");        }        return value;    }    public String getSeqPattern(String pattern,int value) throws Exception     {        if(year2d==null){            ResultSet rs = theConnectionInf.eQuery("select visit_year from t_visit_year");            if(rs.next())                year2d = rs.getString(1);        }        return SequenceData.getDBText(pattern,value,year2d);    }               public String updateSequenceV36(String str,boolean hn_runing,int value) throws Exception    {        if(year2d==null){            ResultSet rs = theConnectionInf.eQuery("select visit_year from t_visit_year");            if(rs.next())                year2d = rs.getString(1);        }        String a = new String();        //ตรวจสอบว่าเป็น sequence ตัวไหนจะมีการจัดการไม่เหมือนกัน มันแปลกๆ ตรงที่รูปแบบมันต่างกัน        DecimalFormat d = new DecimalFormat();        d.applyPattern("000000");        if(str.equalsIgnoreCase("vn")){            a="0" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("xn")){            a = "X" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("dfn")) {            a = "3" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("an")){            a="1" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("rfin")){            a="IN" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("rfon")){            a="OU" + year2d + d.format(value);        }        else if(str.equalsIgnoreCase("hn")){            d.applyPattern("000000000");            a = d.format(value);        }        else if(str.equalsIgnoreCase("rn")){            a="0" + year2d + d.format(value);        }        //ส่วนนี้หมายถึง ถ้าเป็น hn ก็จะต้องเปลี่ยน pattern เป็น 9 หลัก คือ 1+8        else if(hn_runing){            d.applyPattern("000000000");            a="0" + d.format(value);        }        //ส่วน case อื่นๆ ก็ตามนี้ นะ        else {            a="0" +  year2d + d.format(value);        }        return a;    }           public Vector eQuery(String sql) throws Exception    {        SequenceData p;        Vector list = new Vector();        ResultSet rs = theConnectionInf.eQuery(sql);        while(rs.next())        {            p = new SequenceData();            p.setObjectId(rs.getString(dbObj.pk_field));            p.name = rs.getString(dbObj.name);            p.pattern = rs.getString(dbObj.pattern);            p.value = rs.getString(dbObj.value);            p.active = rs.getString(dbObj.active);            list.add(p);        }        rs.close();        return list;    }    //    public static void main(String arg[])//    {        //        ConnectionInf con = new ConnectionDBMgr();//        SequenceDataDB fdf = new SequenceDataDB(con);//        try//        {//            fdf.getMaxHnHCIS(722502);//        }//        catch(Exception ex)//        {//            ex.printStackTrace();//        }//    }}